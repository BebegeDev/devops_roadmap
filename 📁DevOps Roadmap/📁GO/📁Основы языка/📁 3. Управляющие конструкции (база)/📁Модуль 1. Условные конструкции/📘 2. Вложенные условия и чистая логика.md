
## Вложенность условий

Иногда требуется вложить одну конструкцию `if` внутрь другой. Это может быть удобно для проверки зависимых условий, но при чрезмерной вложенности код становится трудночитаемым.

```go
if user != nil {
    if user.IsActive {
        fmt.Println("Пользователь активен")
    }
}
```

Такой код лучше упростить:

```go
if user != nil && user.IsActive {
    fmt.Println("Пользователь активен")
}
```

## Альтернатива вложенности — ранний выход (early return)

Если внутри `if` происходит возврат из функции, можно избавиться от `else`:

```go
func checkAccess(role string) {
    if role != "admin" {
        fmt.Println("Нет доступа")
        return
    }
    fmt.Println("Доступ разрешён")
}
```

Такой стиль делает код плоским и читаемым — это best practice в Go.

## Группировка условий

Если условие слишком длинное, его можно вынести в отдельную функцию или логическое выражение:

```go
if isValid(user) && hasPermission(user) && !user.IsBanned {
    fmt.Println("Доступ открыт")
}
```

Или:

```go
canAccess := isValid(user) && hasPermission(user) && !user.IsBanned
if canAccess {
    fmt.Println("Доступ открыт")
}
```

## Антипаттерны

| Проблема | Решение |
|---------|---------|
| Глубокая вложенность | Использовать `return` и объединять условия |
| Логика в `else`, когда в `if` уже был `return` | Убрать `else`, код и так не выполнится без `return` |
| Повтор условий | Вынести в переменные или отдельную функцию |

## Практика

1. Перепиши вложенные `if`, используя логическое объединение условий (`&&`).
2. Реализуй функцию проверки возраста: если меньше 18 — вернуть ошибку и завершить выполнение.
3. Вынеси сложное условие (`if a && b && c && d`) в отдельную переменную или функцию.
4. Напиши функцию проверки прав доступа, где роль, статус активности и блокировка учитываются вложенно, а затем — перепиши в плоском стиле через `return`.
