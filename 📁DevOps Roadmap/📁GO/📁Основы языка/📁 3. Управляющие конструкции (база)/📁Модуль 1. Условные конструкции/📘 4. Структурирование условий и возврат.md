
## Проблема: вложенность

Многоуровневая вложенность `if` делает код трудным для чтения и сопровождения:

```go
if conditionA {
    if conditionB {
        if conditionC {
            fmt.Println("Все условия выполнены")
        }
    }
}
```

Такой код затруднительно читать, особенно если логика сложная.

## Решение: ранний возврат (early return)

Go поощряет использование `return` внутри `if`, чтобы избежать избыточной вложенности:

```go
func check(x int) {
    if x < 0 {
        fmt.Println("Ошибка: меньше нуля")
        return
    }

    fmt.Println("Обработка значения:", x)
}
```

Это делает код "плоским" и улучшает читаемость.

## Правила хорошего стиля

1. **Проверяй и выходи как можно раньше** (early exit)
2. **Избегай else, если до него был `return`**
3. **Разделяй логические блоки визуально**

## Пример плохой практики

```go
func checkPermission(role string) {
    if role == "admin" {
        fmt.Println("Доступ разрешён")
    } else {
        fmt.Println("Доступ запрещён")
    }
}
```

## Улучшено:

```go
func checkPermission(role string) {
    if role != "admin" {
        fmt.Println("Доступ запрещён")
        return
    }

    fmt.Println("Доступ разрешён")
}
```

## Когда всё же использовать `else`

Иногда `else` оправдан:
- В логике с `if/else if/else`
- Когда `if` не завершает выполнение (`return`, `break`, `continue`)
- Для компактности при простых выражениях

## Практика

1. Напиши функцию проверки числа. Если оно отрицательное — вернуть ошибку, иначе — продолжить.
2. Переделай вложенные `if` в плоский стиль с ранним выходом.
3. Создай функцию проверки доступа по роли и статусу активности. Используй `return` вместо вложенных блоков.
4. Сделай три варианта одной и той же логики: вложенный, плоский, и через `switch`. Сравни читаемость.
