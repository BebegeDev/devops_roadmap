
## Цель

Понять типичные ошибки, возникающие при использовании `range`, и научиться их избегать.

---

## Ошибка 1: Переменные повторного использования

```go
for i, v := range slice {
    go func() {
        fmt.Println(i, v)
    }()
}
```

Ожидаемый вывод: 0 10, 1 20, 2 30  
Фактический: может быть 3 30, 3 30, 3 30

**Решение:** создавать локальные копии

```go
for i, v := range slice {
    i, v := i, v
    go func() {
        fmt.Println(i, v)
    }()
}
```

---

## Ошибка 2: Модификация коллекции во время range

Изменение слайса или map внутри `range` может привести к неожиданным результатам или панике:

```go
for k := range m {
    delete(m, k) // работает, но опасно при чтении и записи
}
```

**Рекомендация:** модифицируй после итерации, либо создай копию ключей заранее.

---

## Ошибка 3: Использование значения `v` после окончания цикла

```go
var result int
for _, v := range numbers {
    result = v
}
fmt.Println("Итог:", result) // Ожидается сумма, но это последний элемент
```

**Решение:** использовать аккумулятор (`result += v`), а не перезапись.

---

## Ошибка 4: Использование только `range` без индекса, когда он нужен

```go
for _, v := range arr {
    if v == arr[2] { // ошибка, не знаем индекс v
        ...
    }
}
```

**Решение:** использовать `i, v := range arr`, если важен индекс.

---

## Практика

1. Создай map, по которому проходишь с `range`, и попробуй удалить элементы — проверь результат.
2. Реализуй `range` по слайсу, где внутри запускается горутина. Исправь её.
3. Сделай цикл, в котором собирается сумма, а не последнее значение.
4. Проанализируй пример с `range` по строке и замени `v` на `rune`, если обрабатываются многобайтовые символы.
5. Напиши 3 куска кода: с ошибкой, с её следствием и с правильным исправлением.
