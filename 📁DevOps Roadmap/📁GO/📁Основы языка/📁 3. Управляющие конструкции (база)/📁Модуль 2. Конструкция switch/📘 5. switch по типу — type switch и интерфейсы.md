
## Что такое `type switch`

`type switch` используется для определения **конкретного типа значения**, которое реализует интерфейс. Это удобно, когда функция работает с переменной типа `interface{}` и нужно узнать её реальный тип в рантайме.

## Синтаксис

```go
switch v := x.(type) {
case int:
    fmt.Println("Целое число", v)
case string:
    fmt.Println("Строка", v)
default:
    fmt.Println("Неизвестный тип")
}
```

- `x` должен быть интерфейсом (`interface{}`)
- `v := x.(type)` — синтаксис доступен **только в `type switch`**
- В каждом `case` переменная `v` автоматически приводит значение к нужному типу

## Пример

```go
func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Println("Это int:", v)
    case float64:
        fmt.Println("Это float64:", v)
    case string:
        fmt.Println("Это строка:", v)
    default:
        fmt.Printf("Неизвестный тип: %T
", v)
    }
}
```

## Когда использовать

- Если пишешь функцию, принимающую `interface{}` и нужно разное поведение в зависимости от типа
- При обработке JSON, input данных, значений разного происхождения
- В логгерах, валидаторах, сериализаторах

## Подводные камни

- `switch v := x.(type)` работает **только внутри switch**
- В обычном коде для приведения типа используют `x.(T)`, и это может вызвать панику, если тип не совпал — лучше использовать `x.(T)` с `ok`:

```go
str, ok := x.(string)
if ok {
    fmt.Println("Строка:", str)
}
```

## Практика

1. Напиши функцию, принимающую `interface{}` и определяющую тип через `type switch`.
2. Создай структуру, которая может принимать `int`, `string`, `bool` и печатать описание типа.
3. Используй `type switch` внутри обработчика JSON-поля, которое может быть строкой или числом.
4. Реализуй логгер, который выводит данные по-разному в зависимости от типа.
