
## Что делает `fallthrough`

В Go, `switch` по умолчанию **не переходит** от одного `case` к другому. Однако с помощью ключевого слова `fallthrough` можно явно указать, что нужно продолжить выполнение следующего блока `case`, даже если его условие не совпадает.

## Пример

```go
value := 1

switch value {
case 1:
    fmt.Println("Один")
    fallthrough
case 2:
    fmt.Println("Два")
    fallthrough
case 3:
    fmt.Println("Три")
default:
    fmt.Println("Завершено")
}
```

Результат:

```
Один
Два
Три
Завершено
```

## Поведение

- `fallthrough` **игнорирует проверку условия следующего `case`**
- Оно просто **выполняет код следующего блока**
- Может быть только **в конце блока `case`**

## Когда использовать

- Для объединения логики нескольких блоков
- В ситуациях, где нужна цепочка действий (редко)

## Когда **не стоит** использовать

- Если `fallthrough` используется только для экономии кода — это ухудшает читаемость
- В большинстве случаев лучше использовать несколько `case` с одинаковым телом

Пример без `fallthrough` (предпочтительно):

```go
switch day {
case "суббота", "воскресенье":
    fmt.Println("Выходной")
}
```

## Ошибки и ограничения

- Нельзя использовать `fallthrough` в последнем `case`
- Нельзя использовать с `switch`, в котором нет тела у следующего `case`

## Практика

1. Создай `switch`, где одно из условий должно выполнить логику следующего блока (`fallthrough`).
2. Попробуй добавить `fallthrough` в последнем `case` и посмотри на ошибку компиляции.
3. Перепиши `fallthrough`-пример, сделав тот же эффект без него.
4. Найди кейс, где `fallthrough` ухудшает читаемость, и перепиши его по-другому.
