Массивы в Go позволяют хранить последовательную коллекцию элементов одного типа фиксированного размера. Понимание того, как объявлять, инициализировать массивы и работать с ними, является основой для работы с более сложными структурами данных, такими как срезы, которые мы рассмотрим на следующем уроке. Массивы — это строительные блоки для многих структур данных и алгоритмов, и глубокое понимание их свойств необходимо для эффективного программирования на Go.

## Объявление массивов

В Go для объявления массива необходимо указать его размер и тип элементов, которые он будет содержать. Синтаксис объявления выглядит следующим образом:

```go
var arrayName [arraySize]dataType
```

- `arrayName`: Имя, которое вы выбираете для своего массива.
- `arraySize`: Количество элементов, которые может хранить массив. Это должно быть константное выражение, которое можно вычислить во время компиляции.
- `dataType`Тип элементов, которые будет содержать массив (например, `int`, `string`, `bool` и т. д.).

**Примеры:**

```go
package main

import "fmt"

func main() {
    // Declare an array of 5 integers
    var numbers [5]int

    // Declare an array of 3 strings
    var names [3]string

    fmt.Println(numbers) // Output: [0 0 0 0 0]
    fmt.Println(names)   // Output: [  ]
}
```

В приведённом выше примере `numbers` — это массив, в который можно поместить 5 целых чисел, а `names` — массив, в который можно поместить 3 строки. Обратите внимание, что при объявлении массива без явной инициализации его элементы автоматически инициализируются нулевыми значениями (0 для целых чисел, "" для строк, `false` для логических значений и т. д.).

### Важные соображения

- **Фиксированный размер:** массивы в Go имеют фиксированный размер, который определяется во время компиляции. После объявления массива с указанием конкретного размера этот размер нельзя изменить. Это ключевое различие между массивами и срезами (о которых мы поговорим на следующем уроке).
- **Однородность типов:** все элементы в массиве должны быть одного типа. Нельзя создать массив, содержащий как целые числа, так и строки.
- **Длина массива:** Длина массива является частью его типа. Это означает, что `[3]int` и `[5]int` — это разные типы.

## Инициализация массивов

Массивы можно инициализировать при объявлении, задав начальные значения для их элементов. В Go есть несколько способов инициализации массивов.

### Явная Инициализация

Вы можете явно инициализировать массив, указав список значений в фигурных скобках `{}`.

**Пример:**

```go
package main

import "fmt"

func main() {
    // Initialize an array of 5 integers with specific values
    var numbers [5]int = [5]int{10, 20, 30, 40, 50}

    // Initialize an array of 3 strings
    var names [3]string = [3]string{"Alice", "Bob", "Charlie"}

    fmt.Println(numbers) // Output: [10 20 30 40 50]
    fmt.Println(names)   // Output: [Alice Bob Charlie]
}
```

В этом примере массив `numbers` инициализируется значениями 10, 20, 30, 40 и 50, а массив `names` — строками «Элис», «Боб» и «Чарли».

### Неявная Инициализация длины

Если вы инициализируете массив списком значений, Go может автоматически определить длину массива. Вы можете использовать синтаксис `...`, чтобы указать, что длина должна определяться по количеству исходных значений.

**Пример:**

```go
package main

import "fmt"

func main() {
    // Initialize an array and let Go infer the length
    var numbers = [...]int{10, 20, 30, 40, 50} // Length is 5

    // Initialize an array of strings with inferred length
    var names = [...]string{"Alice", "Bob", "Charlie"} // Length is 3

    fmt.Println(numbers) // Output: [10 20 30 40 50]
    fmt.Println(names)   // Output: [Alice Bob Charlie]
    fmt.Println(len(numbers)) // Output: 5
    fmt.Println(len(names))   // Output: 3
}
```

В этом случае компилятор определяет длину массива на основе количества элементов, указанных в списке инициализации. Функция `len()` возвращает длину массива.

### Частичная Инициализация

Вы можете частично инициализировать массив, указав значения только для некоторых его элементов. Остальные элементы будут инициализированы нулевыми значениями.

**Пример:**

```go
package main

import "fmt"

func main() {
    // Partially initialize an array of 5 integers
    var numbers [5]int = [5]int{10, 20}

    fmt.Println(numbers) // Output: [10 20 0 0 0]
}
```

В этом примере первые два элемента массива `numbers` инициализируются значениями 10 и 20 соответственно, а остальные три элемента — значением 0.

### Инициализация определённых элементов по индексу

Вы можете инициализировать отдельные элементы массива, указав их индекс в списке инициализации.

**Пример:**

```go
package main

import "fmt"

func main() {
    // Initialize specific elements of an array
    var numbers [5]int = [5]int{0: 10, 4: 50}

    fmt.Println(numbers) // Output: [10 0 0 0 50]
}
```

В этом примере элемент с индексом 0 инициализируется значением 10, а элемент с индексом 4 — значением 50. Остальные элементы инициализируются значением 0.

## Доступ к элементам массива

Доступ к элементам массива осуществляется по их индексу, который начинается с 0 и доходит до `arraySize - 1`. Синтаксис для доступа к элементу:

```go
arrayName[index]
```

**Пример:**

```go
package main

import "fmt"

func main() {
    var numbers [5]int = [5]int{10, 20, 30, 40, 50}

    // Access the element at index 0
    fmt.Println(numbers[0]) // Output: 10

    // Access the element at index 3
    fmt.Println(numbers[3]) // Output: 40

    // Modify the element at index 1
    numbers[1] = 25
    fmt.Println(numbers) // Output: [10 25 30 40 50]
}
```

В этом примере мы обращаемся к элементам по индексам 0 и 3 массива `numbers` и выводим их на экран. Мы также изменяем элемент по индексу 1.

### Важные соображения

- **Индекс вне границ:** обращение к элементу массива с индексом, выходящим за границы (т. е. меньшим 0 или большим или равным размеру массива), приведёт к ошибке во время выполнения. Go выполняет проверку границ, чтобы предотвратить обращение к памяти за пределами массива.

```go
package main

import "fmt"

func main() {
    var numbers [5]int = [5]int{10, 20, 30, 40, 50}

    // Accessing an element with an invalid index will cause a panic
    // fmt.Println(numbers[5]) // This will cause a runtime panic: index out of range [5] with length 5
}
```

## Перебор массивов

Вы можете перебирать элементы массива с помощью цикла `for` Существует два распространённых способа перебора массивов: с помощью цикла на основе индексов и с помощью ключевого слова `range`

### Цикл на основе индекса

Для перебора элементов массива можно использовать традиционный цикл `for` с индексом.

**Пример:**

```go
package main

import "fmt"

func main() {
    var numbers [5]int = [5]int{10, 20, 30, 40, 50}

    // Iterate over the array using an index-based loop
    for i := 0; i < len(numbers); i++ {
        fmt.Printf("Element at index %d: %d\n", i, numbers[i])
    }
}
```

В этом примере цикл `for` выполняется от индекса 0 до `len(numbers) - 1`, выводя на экран значение каждого элемента.

### Ключевое слово Range

Ключевое слово `range` позволяет более лаконично перебирать элементы массива. Возвращает индекс и значение каждого элемента.

**Пример:**

```go
package main

import "fmt"

func main() {
    var numbers [5]int = [5]int{10, 20, 30, 40, 50}

    // Iterate over the array using the range keyword
    for index, value := range numbers {
        fmt.Printf("Element at index %d: %d\n", index, value)
    }

    // If you only need the value, you can use the blank identifier (_) to discard the index
    for _, value := range numbers {
        fmt.Printf("Value: %d\n", value)
    }
}
```

В этом примере ключевое слово `range` выполняет итерацию по массиву `numbers`, предоставляя индекс и значение каждого элемента на каждой итерации. Если вам нужно только значение, вы можете использовать пустой идентификатор `_`, чтобы не учитывать индекс.

## Массивы - это значения

В Go массивы являются значениями. Это означает, что при присваивании одного массива другому создаётся копия всего массива. Изменения, внесённые в копию, не повлияют на исходный массив.

**Пример:**

```go
package main

import "fmt"

func main() {
    var numbers1 [5]int = [5]int{10, 20, 30, 40, 50}
    var numbers2 [5]int = numbers1 // Create a copy of numbers1

    // Modify numbers2
    numbers2[0] = 100

    fmt.Println(numbers1) // Output: [10 20 30 40 50] (original array is unchanged)
    fmt.Println(numbers2) // Output: [100 20 30 40 50] (copy has been modified)
}
```

В этом примере `numbers2` является копией `numbers1`. Когда мы изменяем `numbers2`, исходный массив `numbers1` остаётся неизменным. Такое поведение отличается от поведения срезов, о которых мы поговорим на следующем уроке.

## Практические Упражнения

1. **Сумма элементов массива:** Напишите программу, которая вычисляет сумму всех элементов целочисленного массива.
2. **Обращение массива:** Напишите программу, которая меняет порядок элементов массива на обратный.
3. **Найти максимум:** напишите программу, которая находит максимальное значение в массиве чисел с плавающей запятой.
4. **Массив строк:** Создайте массив строк, содержащий названия месяцев. Выведите название каждого месяца вместе с его порядковым номером.