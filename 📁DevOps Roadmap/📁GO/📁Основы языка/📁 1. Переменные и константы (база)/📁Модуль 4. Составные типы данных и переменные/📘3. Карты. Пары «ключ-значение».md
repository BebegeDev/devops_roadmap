
Карты — это фундаментальная структура данных, которая позволяет хранить и извлекать данные с помощью пар «ключ-значение» Они обеспечивают эффективный поиск значений по связанным с ними ключам В Go карты — это мощный и универсальный инструмент для управления коллекциями данных, в которых каждый элемент может быть однозначно идентифицирован Понимание того, как объявлять, инициализировать, изменять и перебирать карты, крайне важно для написания эффективных программ на Go.

## Объявление и инициализация карт

В Go карты объявляются с помощью ключевого слова `map`, за которым следует тип ключа в квадратных скобках и тип значения.

```go
// Declaring a map where keys are strings and values are integers
var myMap map[string]int
```

Это объявление создаёт переменную map `myMap`, но не выделяет для неё память. На данный момент карта `nil` не используется. Чтобы использовать карту, её нужно инициализировать с помощью функции `make` .

```go
// Initializing the map using the make function
myMap = make(map[string]int)
```

Вы также можете объявить и инициализировать карту в одной строке:

```go
// Declaring and initializing a map in one line
myMap := make(map[string]int)
```

Другой способ инициализации карты — использование литерала карты, который позволяет указать начальные пары «ключ-значение»:

```go
// Initializing a map using a map literal
myMap := map[string]int{
    "apple":  1,
    "banana": 2,
    "cherry": 3,
}
```

### Нулевое значение карты

Нулевое значение карты — `nil`. Карта `nil` не имеет ключей, и в неё нельзя записать данные. Попытка записать данные в карту `nil` приведёт к ошибке. Однако при чтении из карты `nil` будет возвращено нулевое значение типа value.

```go
var myMap map[string]int

// Reading from a nil map returns the zero value of the value type (int in this case, which is 0)
value := myMap["nonexistent_key"]
println(value) // Output: 0

// Writing to a nil map will cause a panic
// myMap["new_key"] = 4 // This will cause a panic
```

## Добавление элементов карты, доступ к ним и их изменение

Чтобы добавить на карту новую пару «ключ-значение», используйте следующий синтаксис:

```go
myMap["grape"] = 4
```

Таким образом, в `myMap` добавляется новый ключ «grape» со значением 4.

Чтобы получить доступ к значению, связанному с ключом, можно использовать следующий синтаксис:

```go
value := myMap["apple"]
println(value) // Output: 1
```

Если ключ существует на карте, будет возвращено соответствующее значение. Если ключ не существует, будет возвращено нулевое значение типа value.

Чтобы изменить значение, связанное с существующим ключом, можно использовать тот же синтаксис, что и при добавлении нового элемента:

```go
myMap["apple"] = 5
println(myMap["apple"]) // Output: 5
```

Это обновляет значение, связанное с ключом «apple», до 5.

### Проверка наличия ключа

При обращении к элементу карты часто бывает важно знать, существует ли ключ на самом деле. Проверить наличие ключа можно с помощью следующего синтаксиса:

```go
value, ok := myMap["apple"]
if ok {
    println("Key exists, value:", value)
} else {
    println("Key does not exist")
}
```

`ok` — это логическая переменная, которая указывает, существует ли ключ на карте. Если ключ существует, `ok` будет равно `true`, а `value` будет содержать соответствующее значение. Если ключ не существует, `ok` будет равно `false`, а `value` будет содержать нулевое значение типа value.

## Удаление элементов карты

Чтобы удалить пару «ключ-значение» из карты, можно использовать функцию `delete`:

```go
delete(myMap, "banana")
```

Это удаляет ключ «banana» и связанное с ним значение из `myMap`. Если ключ отсутствует в карте, функция `delete` ничего не делает.

## Перебор карт

Вы можете перебирать пары «ключ-значение» на карте с помощью цикла `for...range`:

```go
for key, value := range myMap {
    println("Key:", key, "Value:", value)
}
```

Цикл `for...range` перебирает элементы карты и присваивает ключ и значение каждого элемента переменным `key` и `value` соответственно. Порядок перебора элементов не гарантируется при каждом запуске программы. Если вам нужно перебрать элементы карты в определённом порядке, вы можете извлечь ключи в срез, отсортировать срез, а затем перебрать элементы карты, используя отсортированные ключи.

## Карты структур

Карты также могут хранить структуры в качестве значений. Это эффективный способ организации сложных данных и доступа к ним.

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    people := map[string]Person{
        "john.doe": Person{Name: "John Doe", Age: 30},
        "jane.doe": Person{Name: "Jane Doe", Age: 25},
    }

    // Accessing a struct in the map
    person := people["john.doe"]
    println(person.Name) // Output: John Doe

    // Modifying a struct in the map
    person.Age = 31
    people["john.doe"] = person // Important: Maps store copies of structs, so you need to reassign the modified struct

    println(people["john.doe"].Age) // Output: 31
}
```

**Важное примечание:** на картах в Go хранятся _копии_ значений. Когда вы извлекаете структуру из карты, вы получаете копию этой структуры. Если вы изменяете структуру, вам нужно переназначить её обратно на карту, чтобы изменения сохранились.

## Практические примеры и демонстрации

### Пример 1. Подсчёт частоты употребления слов

В этом примере показано, как использовать карту для подсчёта частоты встречаемости каждого слова в строке.

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	text := "this is a test string this is a string"
	words := strings.Fields(text) // Splits the string into a slice of words

	wordFrequencies := make(map[string]int)

	for _, word := range words {
		wordFrequencies[word]++ // Increment the count for each word
	}

	for word, count := range wordFrequencies {
		fmt.Printf("Word: %s, Count: %d\n", word, count)
	}
}
```

### Пример 2. Хранение информации о пользователях

В этом примере показано, как использовать карту для хранения информации о пользователях, где ключами являются идентификаторы пользователей, а значениями — структуры, содержащие сведения о пользователях.

```go
package main

import "fmt"

type User struct {
	ID    int
	Name  string
	Email string
}

func main() {
	users := make(map[int]User)

	// Adding users
	users[1] = User{ID: 1, Name: "Alice", Email: "alice@example.com"}
	users[2] = User{ID: 2, Name: "Bob", Email: "bob@example.com"}

	// Accessing user information
	user1 := users[1]
	fmt.Printf("User ID: %d, Name: %s, Email: %s\n", user1.ID, user1.Name, user1.Email)

	// Iterating over users
	for id, user := range users {
		fmt.Printf("User ID: %d, Name: %s, Email: %s\n", id, user.Name, user.Email)
	}
}
```

### Пример 3. Реализация простого кэша

В этом примере показано, как использовать карту для реализации простого кэша, в котором хранятся результаты ресурсоёмких операций.

```go
package main

import (
	"fmt"
	"time"
)

// Simulate an expensive function
func expensiveOperation(key int) int {
	fmt.Printf("Performing expensive operation for key: %d\n", key)
	time.Sleep(2 * time.Second) // Simulate a delay
	return key * 2
}

func main() {
	cache := make(map[int]int)

	// Function to get value from cache or compute if not present
	getValue := func(key int) int {
		if value, ok := cache[key]; ok {
			fmt.Printf("Fetching from cache for key: %d\n", key)
			return value
		}

		// Compute the value if not in cache
		value := expensiveOperation(key)
		cache[key] = value // Store in cache
		return value
	}

	// First call: computes and stores in cache
	fmt.Println("First call:", getValue(5))

	// Second call: retrieves from cache
	fmt.Println("Second call:", getValue(5))

	// Third call with a different key
	fmt.Println("Third call:", getValue(10))
}
```

## Упражнения

1. **Счётчик частоты слов:** Напишите программу, которая считывает текстовый файл и подсчитывает частоту встречаемости каждого слова в файле. Сохраните частоту встречаемости слов в виде карты и выведите результаты.
2. **Телефонная книга:** Создайте приложение для телефонной книги, которое позволит пользователям добавлять, искать и удалять контакты. Храните контакты на карте, где ключами являются имена, а значениями — номера телефонов.
3. **Простая система учёта:** Реализуйте простую систему учёта для магазина. Используйте карту для хранения информации о количестве каждого товара на складе. Позвольте пользователям добавлять товары, обновлять информацию о количестве и проверять уровень запасов.
4. **Кэш с истечением срока действия:** измените пример с кэшем, добавив время истечения срока действия для каждой записи. По истечении срока действия запись должна быть удалена из кэша. Возможно, вам потребуется использовать структуру для хранения значения и метки времени истечения срока действия.

