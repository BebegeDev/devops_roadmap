
Слайсы и карты — это фундаментальные составные типы данных в Go, которые предоставляют мощные инструменты для организации коллекций данных и управления ими. Слайсы — это динамические массивы, которые могут увеличиваться или уменьшаться по мере необходимости, а карты позволяют хранить и извлекать данные с помощью пар «ключ-значение». Освоение этих структур данных крайне важно для написания эффективных и гибких программ на Go. В этом уроке вы найдёте подробное руководство по созданию, управлению и эффективному использованию слайсов и карт.

## Слайсы: динамические массивы в Go

Слайсы — это мощная абстракция для работы с массивами в Go. В отличие от массивов, слайсы являются динамическими, то есть их размер может меняться во время выполнения программы. Они обеспечивают гибкий способ работы с последовательностями данных.

### Создание фрагментов

В Go есть несколько способов создания срезов:

1. **Использование литерала среза:** это похоже на создание литерала массива, но без указания размера.

```go
package main

import "fmt"

func main() {
    // Creating a slice of integers using a slice literal
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println(numbers) // Output: [1 2 3 4 5]

    // Creating a slice of strings
    names := []string{"Alice", "Bob", "Charlie"}
    fmt.Println(names) // Output: [Alice Bob Charlie]
}
```

2. **Использование функции `make`:** Функция `make` используется для создания срезов с заданной длиной и ёмкостью.

```go
package main

import "fmt"

func main() {
    // Creating a slice of integers with length 5 and capacity 10
    numbers := make([]int, 5, 10)
    fmt.Println(numbers)        // Output: [0 0 0 0 0]
    fmt.Println(len(numbers))  // Output: 5
    fmt.Println(cap(numbers))  // Output: 10

    // Creating a slice of strings with length and capacity 3
    names := make([]string, 3)
    fmt.Println(names)       // Output: [  ]
    fmt.Println(len(names)) // Output: 3
    fmt.Println(cap(names)) // Output: 3
}
```

- `len(slice)` возвращает количество элементов в срезе.
- `cap(slice)` возвращает ёмкость среза, то есть максимальное количество элементов, которое срез может содержать без перераспределения.

**Нарезка существующего массива или среза:** вы можете создать новый срез, нарезав существующий массив или срез.

```go
package main

import "fmt"

func main() {
    // Creating an array
    arr := [5]int{1, 2, 3, 4, 5}

    // Creating a slice from the array
    slice1 := arr[1:4] // Elements from index 1 (inclusive) to 4 (exclusive)
    fmt.Println(slice1) // Output: [2 3 4]

    // Creating a slice from another slice
    slice2 := slice1[0:2]
    fmt.Println(slice2) // Output: [2 3]

    //Slicing with default values
    slice3 := arr[:3] // Equivalent to arr[0:3]
    fmt.Println(slice3) // Output: [1 2 3]

    slice4 := arr[2:] // Equivalent to arr[2:len(arr)]
    fmt.Println(slice4) // Output: [3 4 5]

    slice5 := arr[:] // Equivalent to arr[0:len(arr)] - creates a slice containing all elements of the array
    fmt.Println(slice5) // Output: [1 2 3 4 5]
}
```

### Манипулирование срезами

Слайсы предоставляют несколько встроенных функций и операций для управления их содержимым.

1. **Добавление элементов:** Функция `append` используется для добавления новых элементов в конец среза. Если срез достаточно велик, новые элементы добавляются в существующий базовый массив. Если нет, выделяется новый массив большего размера, и элементы копируются в него.

```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3}
    fmt.Println(numbers)        // Output: [1 2 3]
    fmt.Println(len(numbers))  // Output: 3
    fmt.Println(cap(numbers))  // Output: 3

    // Appending a single element
    numbers = append(numbers, 4)
    fmt.Println(numbers)        // Output: [1 2 3 4]
    fmt.Println(len(numbers))  // Output: 4
    fmt.Println(cap(numbers))  // Output: 6 (capacity doubles when it's full)

    // Appending multiple elements
    numbers = append(numbers, 5, 6)
    fmt.Println(numbers)        // Output: [1 2 3 4 5 6]
    fmt.Println(len(numbers))  // Output: 6
    fmt.Println(cap(numbers))  // Output: 6

    // Appending another slice
    moreNumbers := []int{7, 8}
    numbers = append(numbers, moreNumbers...) // The "..." unpacks the slice
    fmt.Println(numbers)        // Output: [1 2 3 4 5 6 7 8]
    fmt.Println(len(numbers))  // Output: 8
    fmt.Println(cap(numbers))  // Output: 12
}
```

2. **Копирование срезов:** Функция `copy` используется для копирования элементов из одного среза в другой. Она копирует элементы, длина которых минимальна по сравнению с длиной исходного и целевого срезов.

```go
package main

import "fmt"

func main() {
    source := []int{1, 2, 3, 4, 5}
    destination := make([]int, 3)

    // Copying elements from source to destination
    numCopied := copy(destination, source)
    fmt.Println(destination) // Output: [1 2 3]
    fmt.Println(numCopied)   // Output: 3

    //Copying to a larger slice
    destination2 := make([]int, 10)
    numCopied2 := copy(destination2, source)
    fmt.Println(destination2) // Output: [1 2 3 4 5 0 0 0 0 0]
    fmt.Println(numCopied2)   // Output: 5

    //Copying from a smaller slice
    source2 := []int{1, 2}
    destination3 := make([]int, 5)
    numCopied3 := copy(destination3, source2)
    fmt.Println(destination3) // Output: [1 2 0 0 0]
    fmt.Println(numCopied3)   // Output: 2
}
```

3. **Удаление элементов:** встроенной функции для непосредственного удаления элементов из среза нет. Однако этого можно добиться с помощью срезов и добавления элементов.

```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5}

    // Deleting the element at index 2 (value 3)
    index := 2
    numbers = append(numbers[:index], numbers[index+1:]...)
    fmt.Println(numbers) // Output: [1 2 4 5]

    //Deleting the first element
    numbers2 := []int{1, 2, 3, 4, 5}
    numbers2 = numbers2[1:]
    fmt.Println(numbers2) // Output: [2 3 4 5]

    //Deleting the last element
    numbers3 := []int{1, 2, 3, 4, 5}
    numbers3 = numbers3[:len(numbers3)-1]
    fmt.Println(numbers3) // Output: [1 2 3 4]
}
```

### Перебор фрагментов

Вы можете перебирать срезы с помощью цикла `for` или цикла `for...range` .

1. **Использование `for` цикла:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        numbers := []int{1, 2, 3, 4, 5}
    
        for i := 0; i < len(numbers); i++ {
            fmt.Printf("Index: %d, Value: %d\n", i, numbers[i])
        }
    }
    ```
    
2. **Использование `for...range` цикла:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        numbers := []int{1, 2, 3, 4, 5}
    
        for index, value := range numbers {
            fmt.Printf("Index: %d, Value: %d\n", index, value)
        }
    
        //If you only need the value, you can omit the index:
        for _, value := range numbers {
            fmt.Println(value)
        }
    }
    ```
    

### Многомерные срезы

Go поддерживает многомерные срезы, которые представляют собой срезы срезов.

```go
package main

import "fmt"

func main() {
    // Creating a 2D slice
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    // Accessing elements
    fmt.Println(matrix[0][0]) // Output: 1
    fmt.Println(matrix[1][2]) // Output: 6

    // Iterating over the 2D slice
    for i := 0; i < len(matrix); i++ {
        for j := 0; j < len(matrix[i]); j++ {
            fmt.Printf("Row: %d, Column: %d, Value: %d\n", i, j, matrix[i][j])
        }
    }
}
```

## Карты: пары «ключ-значение»

Карты — это встроенный в Go ассоциативный тип данных, также известный как словари или хеш-таблицы в других языках. Они хранят пары «ключ-значение», где каждый ключ уникален в рамках карты, и могут использоваться для эффективного извлечения значений на основе связанных с ними ключей.

### Создание карт

В Go есть несколько способов создания карт:

1. **Использование литерала карты:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        // Creating a map with string keys and integer values
        ages := map[string]int{
            "Alice":   30,
            "Bob":     25,
            "Charlie": 35,
        }
        fmt.Println(ages) // Output: map[Alice:30 Bob:25 Charlie:35]
    
        // Creating a map with integer keys and string values
        names := map[int]string{
            1: "Alice",
            2: "Bob",
            3: "Charlie",
        }
        fmt.Println(names) // Output: map[1:Alice 2:Bob 3:Charlie]
    }
    ```
    
2. **Использование функции `make`:** Функция `make` используется для создания пустой карты. При желании можно указать начальную ёмкость.
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        // Creating an empty map with string keys and integer values
        ages := make(map[string]int)
        fmt.Println(ages) // Output: map[]
    
        // Adding key-value pairs
        ages["Alice"] = 30
        ages["Bob"] = 25
        ages["Charlie"] = 35
        fmt.Println(ages) // Output: map[Alice:30 Bob:25 Charlie:35]
    
        // Creating an empty map with an initial capacity of 10
        names := make(map[int]string, 10)
        fmt.Println(names) // Output: map[]
    
        names[1] = "Alice"
        names[2] = "Bob"
        names[3] = "Charlie"
        fmt.Println(names) // Output: map[1:Alice 2:Bob 3:Charlie]
    }
    ```
    

### Манипулирование Картами

Карты предоставляют несколько способов управления их содержимым.

1. **Добавление или обновление пар «ключ-значение»:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        ages := map[string]int{
            "Alice": 30,
            "Bob":   25,
        }
        fmt.Println(ages) // Output: map[Alice:30 Bob:25]
    
        // Adding a new key-value pair
        ages["Charlie"] = 35
        fmt.Println(ages) // Output: map[Alice:30 Bob:25 Charlie:35]
    
        // Updating an existing value
        ages["Alice"] = 31
        fmt.Println(ages) // Output: map[Alice:31 Bob:25 Charlie:35]
    }
    ```
    
2. **Извлечение значений:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        ages := map[string]int{
            "Alice":   30,
            "Bob":     25,
            "Charlie": 35,
        }
    
        // Retrieving a value by key
        aliceAge := ages["Alice"]
        fmt.Println(aliceAge) // Output: 30
    
        // Checking if a key exists
        age, ok := ages["David"] // ok is true if the key exists, false otherwise
        if ok {
            fmt.Println("David's age:", age)
        } else {
            fmt.Println("David's age not found") // Output: David's age not found
        }
    
        //If you don't need the value, you can use the blank identifier:
        _, ok2 := ages["Alice"]
        if ok2 {
            fmt.Println("Alice exists") // Output: Alice exists
        }
    }
    ```
    
3. **Удаление пар «ключ-значение»:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        ages := map[string]int{
            "Alice":   30,
            "Bob":     25,
            "Charlie": 35,
        }
        fmt.Println(ages) // Output: map[Alice:30 Bob:25 Charlie:35]
    
        // Deleting a key-value pair
        delete(ages, "Bob")
        fmt.Println(ages) // Output: map[Alice:30 Charlie:35]
    
        //Attempting to delete a non-existent key does not cause an error
        delete(ages, "David")
        fmt.Println(ages) // Output: map[Alice:30 Charlie:35]
    }
    ```
    
4. **Проверка длины карты:**
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
        ages := map[string]int{
            "Alice":   30,
            "Bob":     25,
            "Charlie": 35,
        }
        fmt.Println(len(ages)) // Output: 3
    }
    ```
    

### Перебор карт

Вы можете перебирать карты с помощью цикла `for...range` Порядок перебора не обязательно совпадает с порядком вставки элементов.

```go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice":   30,
        "Bob":     25,
        "Charlie": 35,
    }

    for name, age := range ages {
        fmt.Printf("Name: %s, Age: %d\n", name, age)
    }

    //Iterating over keys only
    for name := range ages {
        fmt.Println(name)
    }

    //Iterating over values only
    for _, age := range ages {
        fmt.Println(age)
    }
}
```

### Карты со значениями структуры

Карты могут хранить структуры в качестве значений, что позволяет создавать сложные структуры данных.

```go
package main

import "fmt"

// Defining a struct
type Person struct {
    Name string
    Age  int
}

func main() {
    // Creating a map with string keys and Person struct values
    people := map[string]Person{
        "Alice": {Name: "Alice", Age: 30},
        "Bob":   {Name: "Bob", Age: 25},
    }

    // Accessing struct fields
    fmt.Println(people["Alice"].Name) // Output: Alice

    // Iterating over the map
    for key, person := range people {
        fmt.Printf("Key: %s, Name: %s, Age: %d\n", key, person.Name, person.Age)
    }
}
```

### Когда использовать срезы, а когда — карты

- **Срезы:** используйте срезы, когда вам нужна упорядоченная коллекция элементов и порядок элементов имеет значение. Срезы также подходят, когда вам нужно динамически изменять размер коллекции.
- **Карты:** используйте карты, когда вам нужно хранить и извлекать данные на основе уникальных ключей. Карты идеально подходят для сценариев, в которых вам нужно быстро находить значения по связанным с ними ключам, например в словарях или настройках конфигурации.

## Практические Упражнения

1. **Манипулирование срезом:**
    
    - Создайте срез целых чисел со значениями `[2, 4, 6, 8, 10]`.
    - Добавьте значения `12` и `14` в срез.
    - Создайте новый срез, содержащий только элементы исходного среза с чётными индексами.
    - Выведите на экран исходный фрагмент, добавленный фрагмент и новый фрагмент.
2. **Операции с картой:**
    
    - Создайте карту, в которой ключи — это строки, представляющие имена учащихся, а значения — целые числа, представляющие их оценки.
    - Добавьте на карту следующих учащихся и их баллы:
        - «Алиса»: 85
        - «Боб»: 92
        - «Чарли»: 78
    - Обновите оценку Боба до 95 баллов.
    - Уберите Чарли с карты.
    - Распечатайте карту и укажите на ней количество учащихся.
    - Проверьте, есть ли на карте ученик по имени «Дэвид». Выведите сообщение о том, найден ученик или нет.
3. **Объединение срезов и карт:**
    
    - Создайте набор структур, где каждая структура представляет собой продукт с такими полями, как `ID` (целое число), `Name` (строка) и `Price` (число с плавающей запятой).
    - Создайте карту, в которой ключами будут идентификаторы продуктов, а значениями — соответствующие структуры продуктов из среза.
    - Пройдитесь по карте и выведите подробную информацию о каждом товаре.
    - Рассчитайте среднюю цену всех товаров на карте.

Эти упражнения помогут вам лучше понять, что такое срезы и карты и как их эффективно использовать в программах на Go.

Слайсы и карты — это важные структуры данных в Go, которые обеспечивают гибкие способы управления коллекциями данных. Слайсы представляют собой динамические массивы, которые могут увеличиваться или уменьшаться по мере необходимости, а карты позволяют хранить и извлекать данные с помощью пар «ключ-значение». Зная, как создавать слайсы и карты, управлять ими и выполнять итерации по ним, вы сможете писать более эффективный и выразительный код на Go. В следующем уроке мы рассмотрим структуры, которые позволяют определять пользовательские типы данных с именованными полями.



