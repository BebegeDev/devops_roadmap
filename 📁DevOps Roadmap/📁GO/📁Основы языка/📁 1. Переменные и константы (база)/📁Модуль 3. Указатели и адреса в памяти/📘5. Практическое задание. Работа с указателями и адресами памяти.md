
Указатели — это фундаментальное понятие в Go, позволяющее косвенно манипулировать переменными, работая с их адресами в памяти. В этом упражнении вы получите практический опыт объявления, разыменования и использования указателей для изменения данных, что укрепит ваше понимание того, как работают указатели на низком уровне. Эти знания крайне важны для эффективного управления памятью и создания сложных структур данных в Go.

## Объявление указателей и разыменование указателей

Указатель — это переменная, в которой хранится адрес памяти другой переменной. Чтобы объявить указатель, используйте оператор `*`, за которым следует тип переменной, на которую он указывает. Чтобы получить адрес памяти переменной, используйте оператор `&` . Чтобы получить доступ к значению, хранящемуся по адресу памяти, на который указывает указатель (разыменование), снова используйте оператор `*` .

```go
package main

import "fmt"

func main() {
    var x int = 10
    var p *int // Declare a pointer to an integer

    p = &x // Assign the memory address of x to p

    fmt.Println("Value of x:", x)   // Output: Value of x: 10
    fmt.Println("Address of x:", &x) // Output: Address of x: 0xc00001a0a8 (will vary)
    fmt.Println("Value of p:", p)   // Output: Value of p: 0xc00001a0a8 (same as address of x)
    fmt.Println("Value pointed to by p:", *p) // Output: Value pointed to by p: 10

    *p = 20 // Modify the value of x through the pointer

    fmt.Println("Value of x after modification:", x) // Output: Value of x after modification: 20
}
```

В этом примере:

- `var x int = 10` Объявляется целочисленная переменная `x` и ей присваивается значение 10.
- `var p *int` Объявляется переменная-указатель `p`, которая может хранить адрес целого числа в памяти.
- `p = &x` присваивает `x` адрес памяти `p`.
- `*p = 20` разыменовывает указатель `p` и присваивает значение 20 ячейке памяти, на которую он указывает (то есть переменной `x`).

## Использование указателей для изменения переменных

Указатели особенно полезны, когда нужно изменить значение переменной внутри функции. Без указателей семантика передачи по значению в Go создавала бы копию переменной, и любые изменения внутри функции не влияли бы на исходную переменную.

```go
package main

import "fmt"

func modifyValue(p *int) {
    *p = 100
}

func main() {
    x := 50
    fmt.Println("Value of x before modification:", x) // Output: Value of x before modification: 50

    modifyValue(&x) // Pass the address of x to the function

    fmt.Println("Value of x after modification:", x) // Output: Value of x after modification: 100
}
```

В этом примере:

- `modifyValue` принимает в качестве аргумента указатель на целое число.
- Внутри `modifyValue` `*p = 100` изменяет значение переменной, адрес которой хранится в `p`.
- При вызове `modifyValue(&x)` адрес `x` передаётся функции, что позволяет ей изменять исходный `x`.

### Практический пример: замена значений

Распространённый вариант использования указателей — обмен значениями двух переменных.

```go
package main

import "fmt"

func swap(a *int, b *int) {
    temp := *a
    *a = *b
    *b = temp
}

func main() {
    x := 10
    y := 20

    fmt.Println("Before swap: x =", x, "y =", y) // Output: Before swap: x = 10 y = 20

    swap(&x, &y)

    fmt.Println("After swap: x =", x, "y =", y) // Output: After swap: x = 20 y = 10
}
```

В этом примере:

- Функция `swap` принимает в качестве аргументов указатели на два целых числа.
- Он использует временную переменную `temp` для хранения значения `*a` при обмене значениями.
- Передавая адреса `x` и `y` в `swap`, функция может напрямую изменять их значения.

## Ключевое слово `new` и динамическое распределение памяти

```go
package main

import "fmt"

func main() {
    p := new(int) // Allocate memory for an integer and return a pointer to it

    fmt.Println("Value of p:", p)   // Output: Value of p: 0xc00001a0a8 (will vary)
    fmt.Println("Value pointed to by p:", *p) // Output: Value pointed to by p: 0 (zero value of int)

    *p = 50 // Assign a value to the memory location pointed to by p

    fmt.Println("Value pointed to by p after assignment:", *p) // Output: Value pointed to by p after assignment: 50
}
```

В этом примере:

- `p := new(int)` выделяет память для целого числа и присваивает адрес этой памяти `p`. Выделенная память инициализируется нулевым значением для целого числа, то есть 0.
- `*p = 50` присваивает значение 50 ячейке памяти, на которую указывает `p`.

### Разница между `new` и `&`

Хотя и `new` и `&` можно использовать для получения указателя, они служат разным целям:

- `&` получает адрес _существующей_ переменной.
- `new` _выделяет_ новую память и возвращает указатель на неё.

Рассмотрим этот пример:

```go
package main

import "fmt"

func main() {
    // Using &
    x := 10
    p := &x // p points to the memory location of x

    // Using new
    q := new(int) // q points to a newly allocated memory location

    fmt.Println("Address of x:", &x) // Output: Address of x: 0xc00001a0a8 (will vary)
    fmt.Println("Value of p:", p)   // Output: Value of p: 0xc00001a0a8 (same as address of x)
    fmt.Println("Value of q:", q)   // Output: Value of q: 0xc00001a0b0 (different address)
}
```

