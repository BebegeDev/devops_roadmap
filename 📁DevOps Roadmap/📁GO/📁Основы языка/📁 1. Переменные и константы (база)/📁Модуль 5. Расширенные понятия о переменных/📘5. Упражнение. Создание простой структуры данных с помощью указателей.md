
Создание простой структуры данных с помощью указателей — это фундаментальный навык в Go, который позволяет создавать динамические и эффективные организации данных. Это упражнение основано на вашем понимании структур, указателей и того, как они взаимодействуют для создания сложных взаимосвязей между элементами данных. К концу этого урока вы сможете реализовать базовый связный список — распространённую структуру данных, которая демонстрирует возможности указателей в управлении взаимосвязями данных. Эти знания будут крайне важны для понимания более сложных структур данных и алгоритмов в Go.

## Понимание структуры данных «связанный список»

Связный список — это линейная структура данных, в которой элементы не хранятся в смежных областях памяти. Вместо этого каждый элемент (часто называемый _узлом_) содержит значение и указатель на следующий элемент в последовательности. Указатель последнего элемента указывает на `nil`, обозначая конец списка.

### Ключевые понятия

- **Узел:** базовый элемент связного списка. Он состоит из двух частей:
    - **Данные:** фактическое значение, хранящееся в узле.
    - **Следующий указатель:** указатель на следующий узел в списке. Если это последний узел, то указатель равен `nil`.
- **Голова:** первый узел в связанном списке. Он служит точкой входа в список.
- **Обход:** процесс посещения каждого узла в списке, начиная с заголовка и следуя указателям `next`.

### Преимущества связанных списков

- **Динамический размер:** связанные списки могут динамически увеличиваться или уменьшаться во время выполнения, поскольку узлы можно легко добавлять или удалять.
- **Эффективная вставка/удаление**: вставка или удаление элементов в середине связанного списка выполняется эффективно, поскольку требуется только обновить указатели, в отличие от массивов, в которых элементы нужно сдвигать.

### Недостатки связанных списков

- **Издержки памяти:** каждому узлу требуется дополнительная память для хранения указателя `next`
- **Нет произвольного доступа:** для доступа к элементу в связанном списке необходимо пройти по списку от начала, что делает произвольный доступ неэффективным.
- **Неэффективность кэширования:** из-за неравномерного распределения памяти связанные списки могут быть неэффективны с точки зрения кэширования.

## Реализация связного списка на Go

Давайте реализуем простой связный список на Go с использованием структур и указателей.

### Определение структуры узла

Сначала мы определяем структуру узла в связанном списке:

```go
package main

import "fmt"

// Node represents a node in the linked list
type Node struct {
	Data int   // The data stored in the node
	Next *Node // Pointer to the next node in the list
}
```

В этом коде:

- Мы определяем структуру под названием `Node`.
- `Data` Это целочисленное поле, в котором хранится значение узла.
- `Next` Это указатель на другой `Node`. Этот указатель связывает текущий узел со следующим узлом в списке.

### Создание связанного списка

Теперь давайте создадим функцию для добавления узлов в связанный список. Мы начнём с пустого списка (представленного заголовком `nil`), а затем будем добавлять узлы в начало.

```go
// insertAtBeginning inserts a new node at the beginning of the list
func insertAtBeginning(head *Node, data int) *Node {
	newNode := &Node{Data: data, Next: head} // Create a new node
	return newNode                             // Return the new head
}
```

Объяснение:

1. `insertAtBeginning` в качестве входных данных используется текущий `head` списка и `data` для вставки.
2. Создаётся новый `Node` с использованием синтаксиса `&Node{Data: data, Next: head}` . При этом выделяется память для нового `Node`, инициализируется его `Data`-поле с помощью предоставленного `data` и устанавливается его `Next`-указатель на текущий `head` в списке.
3. Функция возвращает новый узел, который становится новым `head` в списке.

### Обход и печать связанного списка

Чтобы проверить наш связанный список, нам нужно пройтись по нему и вывести его элементы:

```go
// printList traverses the linked list and prints the data of each node
func printList(head *Node) {
	current := head // Start from the head
	for current != nil {
		fmt.Printf("%d -> ", current.Data) // Print the data
		current = current.Next              // Move to the next node
	}
	fmt.Println("nil") // Indicate the end of the list
}
```

Объяснение:

1. `printList` принимает `head` в качестве входных данных.
2. Он инициализирует указатель `current` на `head`.
3. Он перебирает список до тех пор, пока `current` не станет `nil`.
4. Внутри цикла выводится `Data` текущего узла, а затем `current` обновляется, чтобы указывать на следующий узел с помощью `current = current.Next`.
5. Наконец, выводится «nil», обозначающее конец списка.

### Пример Использования

Вот полный пример, демонстрирующий, как использовать эти функции:

```go
package main

import "fmt"

// Node represents a node in the linked list
type Node struct {
	Data int
	Next *Node
}

// insertAtBeginning inserts a new node at the beginning of the list
func insertAtBeginning(head *Node, data int) *Node {
	newNode := &Node{Data: data, Next: head}
	return newNode
}

// printList traverses the linked list and prints the data of each node
func printList(head *Node) {
	current := head
	for current != nil {
		fmt.Printf("%d -> ", current.Data)
		current = current.Next
	}
	fmt.Println("nil")
}

func main() {
	var head *Node // Initialize an empty list

	head = insertAtBeginning(head, 3)
	head = insertAtBeginning(head, 7)
	head = insertAtBeginning(head, 1)

	printList(head) // Output: 1 -> 7 -> 3 -> nil
}
```

В функции `main`:

1. Мы инициализируем `head` значением `nil`, представляющим собой пустой список.
2. Мы вставляем три узла со значениями данных 3, 7 и 1 в начало списка. Обратите внимание, что порядок вставки определяет порядок элементов в списке.
3. Мы вызываем `printList` для вывода содержимого связанного списка.

## Упражнение: реализация удаления с самого начала

Расширьте реализацию связного списка, добавив функцию для удаления узла из начала списка.

```go
// deleteFromBeginning deletes the first node from the list
func deleteFromBeginning(head *Node) *Node {
	if head == nil {
		return nil // List is empty
	}
	newHead := head.Next // The second node becomes the new head
	return newHead
}
```

Добавьте эту функцию в предыдущий код и протестируйте её в функции `main` . Например:

```go
package main

import "fmt"

// Node represents a node in the linked list
type Node struct {
	Data int
	Next *Node
}

// insertAtBeginning inserts a new node at the beginning of the list
func insertAtBeginning(head *Node, data int) *Node {
	newNode := &Node{Data: data, Next: head}
	return newNode
}

// deleteFromBeginning deletes the first node from the list
func deleteFromBeginning(head *Node) *Node {
	if head == nil {
		return nil // List is empty
	}
	newHead := head.Next // The second node becomes the new head
	return newHead
}

// printList traverses the linked list and prints the data of each node
func printList(head *Node) {
	current := head
	for current != nil {
		fmt.Printf("%d -> ", current.Data)
		current = current.Next
	}
	fmt.Println("nil")
}

func main() {
	var head *Node // Initialize an empty list

	head = insertAtBeginning(head, 3)
	head = insertAtBeginning(head, 7)
	head = insertAtBeginning(head, 1)

	fmt.Println("Original List:")
	printList(head) // Output: 1 -> 7 -> 3 -> nil

	head = deleteFromBeginning(head)

	fmt.Println("List after deleting from beginning:")
	printList(head) // Output: 7 -> 3 -> nil
}
```

## Использование указателей со структурами: дополнительные сведения

При работе с указателями и структурами важно понимать, как Go управляет выделением памяти и сборкой мусора.

### Выделение памяти с помощью `new`

Ключевое слово `new` можно использовать для выделения памяти под структуру и возврата указателя на неё. Например:

```go
node := new(Node)
node.Data = 10
```

Это эквивалентно:

```go
node := &Node{}
node.Data = 10
```

Оба подхода выделяют память для структуры `Node` и возвращают указатель на неё. Ключевое слово `new` инициализирует все поля нулевыми значениями.

### Вывоз мусора

В Go реализована автоматическая сборка мусора, то есть вам не нужно вручную освобождать память, выделенную для структур. Сборщик мусора автоматически освобождает память, которая больше не используется. Тем не менее важно избегать утечек памяти и следить за тем, чтобы все указатели обрабатывались должным образом.

