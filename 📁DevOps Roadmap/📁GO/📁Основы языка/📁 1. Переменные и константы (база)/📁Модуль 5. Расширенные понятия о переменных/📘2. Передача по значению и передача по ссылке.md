
В Go понимание того, как данные передаются в функции, имеет решающее значение для написания эффективного и предсказуемого кода. В этом уроке мы рассмотрим фундаментальные концепции «передачи по значению» и «передачи по ссылке», а также их влияние на работу с переменными и управление памятью. Мы изучим, как Go обрабатывает передачу данных для различных типов данных и как указатели играют важную роль в реализации передачи по ссылке. Эти знания необходимы для создания более сложных структур данных и алгоритмов, а также для оптимизации производительности приложений на Go.

## Передача по значению

Передача по значению означает, что при передаче переменной в функцию создаётся _копия_ значения переменной, которая и передаётся в функцию. Любые изменения, внесённые в переменную внутри функции, не влияют на исходную переменную вне функции. Это гарантирует, что исходные данные останутся неизменными, обеспечивая определённый уровень защиты и изоляции данных.

### Как работает Передача по значению

Когда функция получает переменную по значению, среда выполнения Go выделяет новую память для хранения копии переменной. Затем функция работает с этой копией, не затрагивая исходную переменную. Такое поведение характерно для всех основных типов данных в Go, таких как целые числа, числа с плавающей запятой, логические значения и строки.

### Пример: изменение целого числа

```go
package main

import "fmt"

func modifyValue(x int) {
	x = 10 // Modifies the copy of x
	fmt.Println("Inside modifyValue:", x)
}

func main() {
	y := 5
	fmt.Println("Before modifyValue:", y)
	modifyValue(y)
	fmt.Println("After modifyValue:", y)
}
```

В этом примере функция `modifyValue` получает копию целого числа `y`. Внутри функции копия изменяется на 10. Однако исходная переменная `y` в функции `main` остаётся неизменной и равной 5.

### Пример: изменение строки

```go
package main

import "fmt"

func modifyString(s string) {
	s = "Hello from modifyString" // Modifies the copy of s
	fmt.Println("Inside modifyString:", s)
}

func main() {
	str := "Hello from main"
	fmt.Println("Before modifyString:", str)
	modifyString(str)
	fmt.Println("After modifyString:", str)
}
```

Как и в примере с целыми числами, функция `modifyString` получает копию строки `str`. Изменение копии внутри функции не влияет на исходную строку в функции `main` .

### Последствия передачи по значению

- **Целостность данных:** передача по значению гарантирует, что исходные данные будут защищены от непреднамеренных изменений внутри функции.
- **Использование памяти:** создание копий переменных может потребовать больше памяти, особенно при работе с большими структурами данных.
- **Производительность:** копирование больших структур данных также может повлиять на производительность из-за затрат на выделение памяти и копирование данных.

## Передать по ссылке

Передача по ссылке, в отличие от передачи по значению, предполагает передачу _адреса памяти_ переменной в функцию. Это позволяет функции напрямую обращаться к исходной переменной и изменять её. В Go передача по ссылке осуществляется с помощью _указателей_.

### Понимание Указателей

Как было сказано в [модуле 3](obsidian://open?vault=DevOps%20Roadmap&file=%F0%9F%93%81DevOps%20Roadmap%2F%F0%9F%93%81GO%2F%F0%9F%93%81%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%2F%F0%9F%93%81%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B%2F%F0%9F%93%81%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%203.%20%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%B8%20%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%20%D0%B2%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8%2F%F0%9F%93%95%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%203.%20%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%B8%20%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%20%D0%B2%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8), указатель — это переменная, в которой хранится адрес памяти другой переменной. С помощью указателей функции могут косвенно управлять исходными данными.

### Как передача по ссылке работает с указателями

Когда вы передаёте указатель в функцию, функция получает адрес исходной переменной в памяти. Затем функция может использовать этот адрес для разыменования указателя и доступа к базовому значению. Любые изменения, внесённые в значение через указатель, напрямую повлияют на исходную переменную.

```go
package main

import "fmt"

func modifyValueWithPointer(x *int) {
	*x = 10 // Dereferences the pointer and modifies the original value
	fmt.Println("Inside modifyValueWithPointer:", *x)
}

func main() {
	y := 5
	fmt.Println("Before modifyValueWithPointer:", y)
	modifyValueWithPointer(&y) // Passes the address of y
	fmt.Println("After modifyValueWithPointer:", y)
}
```

В этом примере функция `modifyValueWithPointer` получает указатель на целое число `y`. Внутри функции указатель разыменовывается с помощью `*x`, что позволяет функции изменить исходное значение `y`. В результате значение `y` в функции `main` изменяется на 10.

### Пример: изменение строки с помощью указателя

```go
package main

import "fmt"

func modifyStringWithPointer(s *string) {
	*s = "Hello from modifyStringWithPointer" // Dereferences the pointer and modifies the original value
	fmt.Println("Inside modifyStringWithPointer:", *s)
}

func main() {
	str := "Hello from main"
	fmt.Println("Before modifyStringWithPointer:", str)
	modifyStringWithPointer(&str) // Passes the address of str
	fmt.Println("After modifyStringWithPointer:", str)
}
```

Как и в примере с целыми числами, функция `modifyStringWithPointer` получает указатель на строку `str`. Разыменование указателя позволяет функции изменять исходную строку в функции `main` .

### Последствия передачи по ссылке

- **Прямое изменение:** передача по ссылке позволяет функциям напрямую изменять исходные данные, что может быть полезно для обновления сложных структур данных или общих ресурсов.
- **Эффективность использования памяти:** передача указателей позволяет избежать затрат на копирование больших структур данных, что может повысить производительность.
- **Возможность возникновения побочных эффектов:** изменение данных с помощью указателей может привести к непредвиденным побочным эффектам, если не соблюдать осторожность. Крайне важно понимать масштаб и последствия изменения указателей.

## Передача по значению и передача по ссылке: сравнение

|Особенность|Передача по значению|Передача по ссылке (с использованием указателей)|
|---|---|---|
|Переданные данные|Копия значения переменной|Адрес переменной в памяти|
|Модификация|Изменения не затрагивают исходную переменную|Изменения напрямую влияют на исходную переменную|
|Использование памяти|Выше (из-за копирования)|Нижний (позволяет избежать копирования)|
|Защита данных|Выше (исходные данные защищены)|Ниже (вероятность непредвиденных побочных эффектов)|
|Варианты использования|Когда целостность данных имеет решающее значение и изменения внутри функции не должны влиять на исходные данные|Когда требуется прямое изменение исходных данных или при работе с большими структурами данных, чтобы избежать копирования|

## Использование указателей со структурами

Как было сказано в [модуле 4](obsidian://open?vault=DevOps%20Roadmap&file=%F0%9F%93%81DevOps%20Roadmap%2F%F0%9F%93%81GO%2F%F0%9F%93%81%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%2F%F0%9F%93%81%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B%2F%F0%9F%93%81%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%204.%20%D0%A1%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B8%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%2F%F0%9F%93%984.%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B.%20%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80), структуры — это составные типы данных, которые объединяют связанные поля. При работе со структурами особенно важно понимать разницу между передачей по значению и передачей по ссылке.

### Передача по значению со структурами

Когда вы передаёте структуру в функцию по значению, создаётся копия всей структуры. Это означает, что любые изменения, внесённые в поля структуры внутри функции, не повлияют на исходную структуру.

```go
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func modifyPersonValue(p Person) {
	p.Name = "Bob" // Modifies the copy of the struct
	p.Age = 30     // Modifies the copy of the struct
	fmt.Println("Inside modifyPersonValue:", p)
}

func main() {
	person := Person{Name: "Alice", Age: 25}
	fmt.Println("Before modifyPersonValue:", person)
	modifyPersonValue(person)
	fmt.Println("After modifyPersonValue:", person)
}
```

### Передача по ссылке в структурах

Чтобы изменить исходную структуру, нужно передать в функцию указатель на структуру. Это позволит функции напрямую обращаться к полям структуры и изменять их.

```go
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func modifyPersonPointer(p *Person) {
	p.Name = "Bob" // Modifies the original struct through the pointer
	p.Age = 30     // Modifies the original struct through the pointer
	fmt.Println("Inside modifyPersonPointer:", *p)
}

func main() {
	person := Person{Name: "Alice", Age: 25}
	fmt.Println("Before modifyPersonPointer:", person)
	modifyPersonPointer(&person) // Passes the address of the struct
	fmt.Println("After modifyPersonPointer:", person)
}
```

В этом примере функция `modifyPersonPointer` получает указатель на структуру `Person` . Изменение полей `Name` и `Age` через указатель напрямую влияет на исходную структуру `person` в функции `main` .

### Когда следует использовать указатели со структурами

- **Изменение полей структуры.** Если вам нужно изменить поля структуры внутри функции и чтобы эти изменения отразились за пределами функции, используйте указатель на структуру.
- **Большие структуры:** для больших структур передача указателя может быть более эффективной, чем передача по значению, поскольку позволяет избежать затрат на копирование всей структуры.
- **Проверка на nil:** если структура может быть равна nil, использование указателя позволяет проверить, не равна ли она nil, прежде чем обращаться к её полям, что предотвращает возможные сбои.

