
Реализация связного списка с использованием указателей и структур в Go — это классический пример того, как эти концепции работают вместе для создания динамических структур данных. Связные списки обеспечивают гибкий способ хранения данных и управления ими, особенно когда размер данных неизвестен заранее или когда требуется частое добавление и удаление элементов. В этом уроке вы подробно разберёте процесс создания связного списка.

## Понимание Связанных списков

Связный список — это линейная структура данных, в которой элементы не хранятся в смежных ячейках памяти. Вместо этого каждый элемент (называемый узлом) содержит значение и указатель на следующий узел в последовательности. Последний узел в списке указывает на `nil`. Такая структура позволяет эффективно добавлять и удалять элементы, поскольку нужно обновлять только указатели, а не сдвигать элементы в памяти, как в случае с массивом.

### Структура узла

Основным строительным блоком связного списка является узел. В Go мы можем представить узел в виде структуры, содержащей данные и указатель на следующий узел.

```go
type Node struct {
    Data interface{} // Data stored in the node
    Next *Node       // Pointer to the next node in the list
}
```

В этом примере `Data` имеет тип `interface{}`. Это означает, что он может содержать значения любого типа. Это обеспечивает гибкость, но требует приведения типа при извлечении данных. `Next` — это указатель на следующий `Node` в списке. Если это последний узел, `Next` будет равно `nil`.

### Структура связанного списка

Связный список — это структура, содержащая указатель на первый узел (голову) списка.

```go
type LinkedList struct {
    Head *Node // Pointer to the first node in the list
}
```

Связный список — это структура, содержащая указатель на первый узел (голову) списка.

```go
type LinkedList struct {
    Head *Node // Pointer to the first node in the list
}
```

Указатель `Head` является точкой входа в список. Если `Head` равно `nil`, то список пуст.

## Выполнение Основных операций

Теперь давайте реализуем несколько базовых операций для нашего связного списка: добавление узла, обход списка и удаление узла.

### Добавление узла

Добавление узла в начало списка — распространённая операция. Вот как её можно реализовать:

```go
func (ll *LinkedList) Add(data interface{}) {
    newNode := &Node{Data: data, Next: ll.Head} // Create a new node
    ll.Head = newNode                           // Update the head to point to the new node
}
```

Эта функция создаёт новый узел с заданными данными и устанавливает его `Next`-указатель на текущую голову списка. Затем она обновляет `Head`-указатель списка, чтобы он указывал на новый узел, тем самым добавляя новый узел в начало списка.

_Пример:_

```go
list := LinkedList{}
list.Add(10)
list.Add("hello")
list.Add(true)
```

В этом примере мы создаём новый связанный список и добавляем в него три узла с разными типами данных: целое число, строку и логическое значение.

### Перемещение по списку

Обход списка подразумевает посещение каждого узла списка и выполнение определённой операции с данными. Вот как можно вывести данные каждого узла:

```go
func (ll *LinkedList) Traverse() {
    current := ll.Head // Start from the head
    for current != nil {  // Iterate until the end of the list
        fmt.Println(current.Data) // Print the data
        current = current.Next    // Move to the next node
    }
}
```

Эта функция начинает работу с начала списка и перебирает каждый узел, пока не дойдёт до конца (где `Next` — это `nil`). На каждой итерации она выводит данные текущего узла и переходит к следующему узлу.

_Пример:_

```go
list := LinkedList{}
list.Add(10)
list.Add("hello")
list.Add(true)
list.Traverse() // Output: true, hello, 10
```

В этом примере в список добавляются три узла, а затем выполняется обход списка с выводом данных каждого узла.

### Удаление узла

Чтобы удалить узел, нужно найти его и обновить указатели соседних узлов. Вот как можно удалить узел с определённым значением данных:

```go
func (ll *LinkedList) Delete(data interface{}) {
    if ll.Head == nil { // If the list is empty, return
        return
    }

    if ll.Head.Data == data { // If the head node contains the data to delete
        ll.Head = ll.Head.Next // Update the head to the next node
        return
    }

    current := ll.Head
    for current.Next != nil {
        if current.Next.Data == data {
            current.Next = current.Next.Next // Update the pointer to skip the node to delete
            return
        }
        current = current.Next // Move to the next node
    }
}
```

Сначала эта функция проверяет, пуст ли список. Если нет, она проверяет, содержит ли головной узел данные, которые нужно удалить. Если да, она обновляет головной узел, указывая на следующий узел. В противном случае она перебирает список, пока не найдёт узел, который нужно удалить. Найдя узел, она обновляет `Next` указатель предыдущего узла, чтобы пропустить узел, который нужно удалить.

_Пример:_

```go
list := LinkedList{}
list.Add(10)
list.Add("hello")
list.Add(true)
list.Delete("hello")
list.Traverse() // Output: true, 10
```

В этом примере в список добавляются три узла, удаляется узел с данными «hello», а затем выполняется обход списка с выводом данных оставшихся узлов.

## Использование указателей со структурами в связанных списках

Указатели играют ключевую роль в связанных списках, поскольку они позволяют связывать узлы между собой. Без указателей каждый узел был бы изолирован в памяти, и мы не смогли бы перемещаться по списку.

### Выделение памяти

При создании нового узла необходимо выделить для него память. В Go для выделения памяти можно использовать ключевое слово `new` или оператор `&` .

```go
newNode := new(Node) // Using the new keyword
newNode := &Node{}   // Using the & operator
```

Оба этих метода выделяют память для новой `Node` структуры и возвращают указатель на выделенную память. Ключевое слово `new` возвращает указатель на обнулённое значение указанного типа. Оператор `&` возвращает указатель на вновь созданный литерал структуры.

### Передать по ссылке

Когда вы передаёте связанный список в функцию, вы обычно передаёте указатель на список. Это позволяет функции напрямую изменять список. Это называется «передача по ссылке».

```go
func modifyList(ll *LinkedList) {
    ll.Add(20) // Modifies the original list
}

list := LinkedList{}
list.Add(10)
modifyList(&list)
list.Traverse() // Output: 20, 10
```

В этом примере функция `modifyList` принимает в качестве аргумента указатель на `LinkedList` . Когда функция добавляет новый узел в список, она изменяет исходный список, а не его копию.

## Расширенные операции

### Вставка в определённое место

Чтобы вставить узел в определённое место, нужно пройти по списку, чтобы найти нужную позицию, а затем обновить указатели.

```go
func (ll *LinkedList) InsertAt(data interface{}, position int) {
    newNode := &Node{Data: data}

    if position == 0 {
        newNode.Next = ll.Head
        ll.Head = newNode
        return
    }

    current := ll.Head
    for i := 0; i < position-1 && current != nil; i++ {
        current = current.Next
    }

    if current == nil {
        fmt.Println("Position out of range")
        return
    }

    newNode.Next = current.Next
    current.Next = newNode
}
```

Эта функция вставляет новый узел с заданными данными в указанную позицию. Если позиция равна 0, узел добавляется в начало списка. В противном случае функция обходит список, чтобы найти узел в позиции -1, и обновляет указатели для вставки нового узла.

### Переворачивание связанного списка

Чтобы перевернуть связанный список, нужно изменить направление указателей так, чтобы последний узел стал первым и так далее.

```go
func (ll *LinkedList) Reverse() {
    var prev *Node
    current := ll.Head
    var next *Node

    for current != nil {
        next = current.Next  // Store the next node
        current.Next = prev  // Reverse the pointer
        prev = current       // Move pointers one position ahead
        current = next
    }

    ll.Head = prev // Update the head to the new first node
}
```

Эта функция перебирает список, меняя местами `Next` указатель каждого узла. Она использует три указателя: `prev`, `current`, и `next`. `prev` указывает на предыдущий узел, `current` указывает на текущий узел, а `next` указывает на следующий узел. На каждой итерации указатель `Next` текущего узла меняется местами с указателем предыдущего узла, а затем указатели перемещаются на одну позицию вперёд.

## Упражнения

1. **Реализуйте функцию для определения длины связанного списка.** Эта функция должна обходить список и подсчитывать количество узлов.
2. **Реализуйте функцию для поиска определённого значения в связанном списке.** Эта функция должна пройти по списку и вернуть `true`, если значение найдено, и `false` в противном случае.
3. **Реализуйте функцию для удаления последнего узла в связанном списке.**
4. **Создайте метод `String()` для структуры `LinkedList`, который возвращает строковое представление списка.** Этот метод должен проходить по списку и объединять данные каждого узла в строку.