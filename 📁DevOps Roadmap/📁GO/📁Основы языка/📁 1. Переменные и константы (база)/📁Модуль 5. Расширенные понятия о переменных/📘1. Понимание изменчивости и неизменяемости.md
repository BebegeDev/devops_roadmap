
Изменяемость и неизменяемость — фундаментальные понятия в программировании, которые определяют, можно ли изменить состояние переменной после её создания. Понимание этих концепций крайне важно для написания безопасного, предсказуемого и удобного в сопровождении кода на Go. В этом уроке мы рассмотрим различия между изменяемыми и неизменяемыми типами данных в Go, то, как они влияют на поведение программы, и то, как их эффективно использовать. Мы также рассмотрим различия между передачей по значению и передачей по ссылке, чтобы подготовить почву для более сложных тем, таких как работа с указателями и структурами, которые мы будем изучать на последующих уроках.

## Понимание Изменчивости

Изменяемость — это возможность изменить значение переменной после её создания. В Go некоторые типы данных являются изменяемыми, то есть их внутреннее состояние можно изменять напрямую.

### Изменяемые типы данных в Go

- **Срезы:** Срезы — это динамические массивы, элементы которых можно изменять после создания среза. Вы можете изменять значения элементов, добавлять новые элементы или удалять существующие.
- **Карты:** Карты представляют собой пары «ключ-значение», и как значения, связанные с ключами, так и сами ключи (если вы заменяете существующий ключ новым) могут быть изменены. Вы можете добавлять новые пары «ключ-значение», обновлять существующие значения или удалять записи.
- **Структуры (в некоторых случаях):** Структуры — это составные типы данных, которые объединяют переменные разных типов. Изменяемость структуры зависит от того, как она используется и экспортируются ли её поля (то есть начинаются ли они с заглавной буквы). Если у вас есть указатель на структуру, вы можете изменять её поля.

**Пример: Изменчивость среза**

```go
package main

import "fmt"

func main() {
    // Create a slice of integers
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println("Original slice:", numbers) // Output: Original slice: [1 2 3 4 5]

    // Modify an element in the slice
    numbers[0] = 10
    fmt.Println("Modified slice:", numbers) // Output: Modified slice: [10 2 3 4 5]

    // Append a new element to the slice
    numbers = append(numbers, 6)
    fmt.Println("Appended slice:", numbers) // Output: Appended slice: [10 2 3 4 5 6]
}
```

В этом примере мы можем напрямую изменять элементы среза `numbers` и добавлять новые элементы, демонстрируя его изменяемость.

**Пример: Изменчивость карты**

```go
package main

import "fmt"

func main() {
    // Create a map of strings to integers
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }
    fmt.Println("Original map:", ages) // Output: Original map: map[Alice:30 Bob:25]

    // Modify a value in the map
    ages["Alice"] = 31
    fmt.Println("Modified map:", ages) // Output: Modified map: map[Alice:31 Bob:25]

    // Add a new key-value pair to the map
    ages["Charlie"] = 28
    fmt.Println("Added map:", ages) // Output: Added map: map[Alice:31 Bob:25 Charlie:28]

    // Delete a key-value pair from the map
    delete(ages, "Bob")
    fmt.Println("Deleted map:", ages) // Output: Deleted map: map[Alice:31 Charlie:28]
}
```

Здесь мы можем изменять значения, связанные с ключами, добавлять новые пары «ключ-значение» и удалять записи из карты `ages`, что демонстрирует её изменяемый характер.

## Понимание Неизменности

Неизменяемость означает, что после создания переменной её значение нельзя изменить. Хотя в Go нет строгого требования к неизменяемости для всех типов данных, некоторые типы данных по своей сути являются неизменяемыми, и вы можете добиться неизменяемости с помощью продуманного дизайна.

### Неизменяемые типы данных в Go

- **Основные типы данных (int, float, bool, string):** эти примитивные типы данных неизменяемы. Когда вы выполняете операцию, которая, как вам кажется, изменяет их, на самом деле вы создаёте новую переменную с обновлённым значением.
- **Массивы (в некоторой степени):** хотя _элементы_ массива можно изменять, сам массив (его размер и расположение в памяти) фиксирован. Вы не можете изменить размер массива после его создания.
- **Константы:** Константы, объявленные с помощью ключевого слова `const`, являются явно неизменяемыми. Их значения должны быть известны во время компиляции и не могут быть изменены во время выполнения программы.

**Пример: неизменяемость строк**

```go
package main

import "fmt"

func main() {
    // Create a string
    message := "hello"
    fmt.Println("Original string:", message) // Output: Original string: hello

    // Attempt to modify the string (this will create a new string)
    newMessage := message + ", world!"
    fmt.Println("Modified string:", newMessage) // Output: Modified string: hello, world!

    // The original string remains unchanged
    fmt.Println("Original string (unchanged):", message) // Output: Original string (unchanged): hello
}
```

В этом примере объединение с помощью `message` не изменяет исходную строку. Вместо этого создается новая строка `newMessage` с объединенным значением. Исходная строка `message` остается неизменной, что демонстрирует неизменяемость строк.

**Пример: неизменяемость целых чисел**

```go
package main

import "fmt"

func main() {
    // Create an integer variable
    x := 10
    fmt.Println("Original x:", x) // Output: Original x: 10

    // Perform an operation that appears to modify x
    x = x + 5
    fmt.Println("Modified x:", x) // Output: Modified x: 15

    // In reality, a new memory location is assigned to x with the new value
}
```

Хотя кажется, что мы изменяем `x`, на самом деле мы присваиваем новое значение `x`. Исходное значение `10` не изменяется напрямую в памяти.

## Передача по значению и передача по ссылке

Понимание изменчивости тесно связано с концепциями передачи по значению и передачи по ссылке. Go — это язык с передачей по значению, то есть при передаче переменной в функцию передаётся копия значения переменной, а не сама исходная переменная.

### Передача по значению

Когда переменная передаётся по значению, любые изменения, внесённые в переменную внутри функции, не влияют на исходную переменную вне функции. Это происходит потому, что функция работает с копией значения.

**Пример: передача значения целого числа**

```go
package main

import "fmt"

func modifyValue(x int) {
    x = x + 10
    fmt.Println("Inside function:", x) // Output: Inside function: 20
}

func main() {
    // Create an integer variable
    number := 10
    fmt.Println("Before function call:", number) // Output: Before function call: 10

    // Call the function, passing the variable by value
    modifyValue(number)

    // The original variable remains unchanged
    fmt.Println("After function call:", number) // Output: After function call: 10
}
```

В этом примере функция `modifyValue` получает _копию_ переменной `number` . Изменение `x` внутри функции не влияет на исходную `number` переменную в функции `main` .

### Передача по ссылке (с использованием указателей)

Чтобы добиться эффекта передачи по ссылке в Go, используйте указатели. Указатель содержит адрес переменной в памяти. Когда вы передаёте указатель в функцию, функция может напрямую обращаться к исходной переменной и изменять её.

**Пример: передача по ссылке с помощью указателя**

```go
package main

import "fmt"

func modifyValueWithPointer(x *int) {
    *x = *x + 10 // Dereference the pointer to access the value
    fmt.Println("Inside function:", *x) // Output: Inside function: 20
}

func main() {
    // Create an integer variable
    number := 10
    fmt.Println("Before function call:", number) // Output: Before function call: 10

    // Call the function, passing the address of the variable (a pointer)
    modifyValueWithPointer(&number)

    // The original variable is modified
    fmt.Println("After function call:", number) // Output: After function call: 20
}
```

В этом примере мы передаём _адрес_ переменной `number` в функцию `modifyValueWithPointer` с помощью оператора `&` . Внутри функции мы используем оператор `*` для _разыменования_ указателя, что позволяет нам напрямую обращаться к исходной переменной `number` и изменять её.

### Изменчивость и передача по значению/ссылке

Сочетание изменяемости и передачи по значению/ссылке имеет большое значение:

- **Изменяемые типы данных, передаваемые по значению:** если вы передаёте изменяемый тип данных (например, срез или карту) по значению, функция получает _копию_ заголовка среза или карты. Заголовок содержит указатель на базовые данные. Хотя заголовок копируется, базовые данные _не_ копируются. Это означает, что если вы измените _содержимое_ среза или карты внутри функции, эти изменения _будут_ отражены в исходном срезе или карте за пределами функции, поскольку и оригинал, и копия указывают на одни и те же базовые данные. Однако если вы измените сам заголовок среза (например, добавив что-то в срез), это не повлияет на исходный срез, поскольку копия теперь указывает на другой базовый массив.
- **Неизменяемые типы данных, передаваемые по значению:** если вы передаёте неизменяемый тип данных (например, целое число или строку) по значению, функция получает копию этого значения. Любые изменения, внесённые в копию внутри функции, не повлияют на исходную переменную.
- **Любой тип данных, передаваемый по ссылке (с использованием указателей):** если вы передаёте указатель на любой тип данных, функция может напрямую изменять исходную переменную, независимо от того, является ли тип данных изменяемым или неизменяемым.

**Пример: изменяемый срез, передаваемый по значению**

```go
package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100 // Modify the underlying data
    s = append(s, 400) // Modify the slice header (creates a new slice)
    fmt.Println("Inside function:", s) // Output: Inside function: [100 2 3 400]
}

func main() {
    // Create a slice
    numbers := []int{1, 2, 3, 4}
    fmt.Println("Before function call:", numbers) // Output: Before function call: [1 2 3 4]

    // Call the function, passing the slice by value
    modifySlice(numbers)

    // The original slice's underlying data is modified, but the header is not
    fmt.Println("After function call:", numbers) // Output: After function call: [100 2 3 4]
}
```

В этом примере изменение `s[0]` внутри `modifySlice` _does_ влияет на исходный `numbers` срез, поскольку оба среза указывают на один и тот же базовый массив. Однако при добавлении в `s` создаётся _новый_ срез с другим базовым массивом, поэтому операция добавления не влияет на исходный `numbers` срез.

### Изменчивость и передача по значению/ссылке

Сочетание изменяемости и передачи по значению/ссылке имеет большое значение:

- **Изменяемые типы данных, передаваемые по значению:** если вы передаёте изменяемый тип данных (например, срез или карту) по значению, функция получает _копию_ заголовка среза или карты. Заголовок содержит указатель на базовые данные. Хотя заголовок копируется, базовые данные _не_ копируются. Это означает, что если вы измените _содержимое_ среза или карты внутри функции, эти изменения _будут_ отражены в исходном срезе или карте за пределами функции, поскольку и оригинал, и копия указывают на одни и те же базовые данные. Однако если вы измените сам заголовок среза (например, добавив что-то в срез), это не повлияет на исходный срез, поскольку копия теперь указывает на другой базовый массив.
- **Неизменяемые типы данных, передаваемые по значению:** если вы передаёте неизменяемый тип данных (например, целое число или строку) по значению, функция получает копию этого значения. Любые изменения, внесённые в копию внутри функции, не повлияют на исходную переменную.
- **Любой тип данных, передаваемый по ссылке (с использованием указателей):** если вы передаёте указатель на любой тип данных, функция может напрямую изменять исходную переменную, независимо от того, является ли тип данных изменяемым или неизменяемым.

**Пример: изменяемый срез, передаваемый по значению**

```go
package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100 // Modify the underlying data
    s = append(s, 400) // Modify the slice header (creates a new slice)
    fmt.Println("Inside function:", s) // Output: Inside function: [100 2 3 400]
}

func main() {
    // Create a slice
    numbers := []int{1, 2, 3, 4}
    fmt.Println("Before function call:", numbers) // Output: Before function call: [1 2 3 4]

    // Call the function, passing the slice by value
    modifySlice(numbers)

    // The original slice's underlying data is modified, but the header is not
    fmt.Println("After function call:", numbers) // Output: After function call: [100 2 3 4]
}
```

В этом примере изменение `s[0]` внутри `modifySlice` _does_ влияет на исходный `numbers` срез, поскольку оба среза указывают на один и тот же базовый массив. Однако при добавлении в `s` создаётся _новый_ срез с другим базовым массивом, поэтому операция добавления не влияет на исходный `numbers` срез.

## Практическое применение и лучшие практики

- **Разберитесь с типом данных:** определите, являются ли типы данных, с которыми вы работаете, изменяемыми или неизменяемыми. Это поможет вам спрогнозировать поведение вашего кода и избежать непредвиденных побочных эффектов.
- **Используйте указатели с осторожностью:** используйте указатели, когда вам нужно изменить исходную переменную внутри функции. Однако будьте осторожны при использовании указателей, так как они могут усложнить понимание кода и привести к ошибкам, если их неправильно использовать.
- **Рассмотрите возможность использования неизменяемых типов данных для обеспечения безопасности.** В ситуациях, когда необходимо гарантировать, что значение переменной не будет изменено, рассмотрите возможность использования неизменяемых типов данных или создания копий изменяемых типов данных. Это поможет предотвратить случайные изменения и сделает ваш код более надёжным.
- **Защитное копирование:** при передаче изменяемых структур данных в функции, особенно если эти функции могут изменять данные, рекомендуется создавать защитную копию структуры данных. Это гарантирует, что исходные данные останутся неизменными.